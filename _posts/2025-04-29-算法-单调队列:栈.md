---
layout:     post
title:      å•è°ƒé˜Ÿåˆ—/å•è°ƒæ ˆ
subtitle:   å•è°ƒé˜Ÿåˆ—/å•è°ƒæ ˆ
date:       2025-04-29
author:     SHK
header-img: img/post-bg-debug.png
catalog: true
tags:
    - ç®—æ³•é¢˜
    - å•è°ƒæ ˆ
    - å•è°ƒé˜Ÿåˆ—
---

# å•è°ƒé˜Ÿåˆ—/å•è°ƒæ ˆ

## **ğŸ§® å•è°ƒé˜Ÿåˆ—ç›¸å…³é¢˜ç›®ï¼ˆMonotonic Queueï¼‰**

**å•è°ƒé˜Ÿåˆ—ï¼ˆMonotonic Queueï¼‰** æ˜¯ä¸€ç§ç‰¹æ®Šçš„åŒç«¯é˜Ÿåˆ—ï¼ˆdequeï¼‰ï¼Œ**ä¿æŒå…¶ä¸­çš„å…ƒç´ å•è°ƒé€’å¢æˆ–é€’å‡**ï¼Œå¹¶ç”¨äºåœ¨**æ»‘åŠ¨çª—å£ç±»**é—®é¢˜ä¸­å¿«é€Ÿæ‰¾åˆ°**æœ€å¤§å€¼æˆ–æœ€å°å€¼**ã€‚

### **å•è°ƒé€’å‡é˜Ÿåˆ—ï¼ˆå¸¸ç”¨äºæ‰¾æœ€å¤§å€¼ï¼‰**

æ¯æ¬¡æ–°å…ƒç´ è¿›æ¥æ—¶ï¼š

1. **æŠŠé˜Ÿå°¾æ‰€æœ‰å°äºæ–°å…ƒç´ çš„å€¼å¼¹å‡º**ï¼ˆå› ä¸ºå®ƒä»¬ä»¥åä¸ä¼šå†æˆä¸ºæœ€å¤§å€¼ï¼‰
2. ç„¶åå†å°†å½“å‰å…ƒç´ åŠ å…¥é˜Ÿå°¾
3. çª—å£æ»‘å‡ºæ—¶ï¼Œå¦‚æœé˜Ÿé¦–å…ƒç´ å·²ä¸åœ¨çª—å£èŒƒå›´ï¼Œå°±å¼¹å‡ºå®ƒ

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque()
        ans = []
        left, right = 0, 0
        for right in range(len(nums)):
            while q and nums[q[-1]] < nums[right]:
                q.pop()
            q.append(right)
            if right >= k - 1:
                ans.append(nums[q[0]])
                if q[0] <= left:
                    q.popleft()
                left += 1
                
        return ans
```

### **å•è°ƒé€’å¢é˜Ÿåˆ—ï¼ˆå¸¸ç”¨äºæ‰¾æœ€å°å€¼ï¼‰**

1. **239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/sliding-window-maximum/

   ä½¿ç”¨å•è°ƒé€’å‡é˜Ÿåˆ—ç»´æŠ¤å½“å‰çª—å£å†…çš„æœ€å¤§å€¼ã€‚

2. **1438. ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

   éœ€è¦åŒæ—¶ç»´æŠ¤æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œå¯ä½¿ç”¨ä¸¤ä¸ªå•è°ƒé˜Ÿåˆ—ã€‚

   ```python
   class Solution:
       def longestSubarray(self, nums: List[int], limit: int) -> int:
           max_queue, min_queue = deque(), deque()
           left, right = 0, 0
           n = len(nums)
           answer = []
           for right in range(n):
               while max_queue and nums[max_queue[-1]] < nums[right]:
                   max_queue.pop()
               max_queue.append(right)
               while min_queue and nums[min_queue[-1]] > nums[right]:
                   min_queue.pop()
               min_queue.append(right)
               while nums[max_queue[0]] - nums[min_queue[0]] > limit:
                   left += 1
                   if max_queue[0] < left:
                       max_queue.popleft()
                   if min_queue[0] < left:
                       min_queue.popleft()
               answer.append(right - left + 1)
           return max(answer)

3. **862. å’Œè‡³å°‘ä¸º K çš„æœ€çŸ­å­æ•°ç»„**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/

   ä½¿ç”¨å‰ç¼€å’Œå’Œå•è°ƒé˜Ÿåˆ—ä¼˜åŒ–æ»‘åŠ¨çª—å£ã€‚æ³¨æ„ï¼Œå‰ç¼€å’Œæ²¡æ³•è¿›è¡Œ å‰å‡å»åï¼Œè¿™ä¸ªæ–¹æ³•æœ‰é—®é¢˜.
   
   æ­£ç¡®è§£æ³•ï¼šç”¨å½“å‰çš„curSumå‡å»ä¹‹å‰æœ€å°çš„min_queueå³å¯
   
   ```python
   class Solution:
       def shortestSubarray(self, nums: List[int], k: int) -> int:
           # sum[l,r] = prefix[r] - prefix[l]
           # æ•°ç»„pä¸­ï¼Œæ‰¾åˆ°p[j]-p[i] >= k ä¸€ä¸ªåŒºé—´å†…çš„æœ€å¤§å€¼ - æœ€å°å€¼
           prefix = [0]
           n = len(nums)
           left, right = 0, 0
           res = -1
           for i in range(n):
               prefix.append(prefix[i] + nums[i])
           max_queue = deque()
           min_queue = deque()
           for right in range(n+1):
               while min_queue and prefix[min_queue[-1]] > prefix[right]:
                   min_queue.pop()  
               min_queue.append(right)
   
               #å»æ‰ä¸åˆæ³•çš„max_queue
               while max_queue and max_queue[0] < min_queue[0]:
                   max_queue.popleft()
               while max_queue and prefix[max_queue[-1]] < prefix[right]:
                   max_queue.pop()
               max_queue.append(right)
   
               while prefix[max_queue[0]] - prefix[min_queue[0]] >= k:
                   temp = max_queue[0] - min_queue[0]
                   if temp > 0:
                       temp = temp
                   else:
                       temp = -temp
                   if res == -1:
                       res = temp
                   else:
                       res = min(res, temp)
                   left += 1
                   if max_queue[0] < left:
                       max_queue.popleft()
                   if min_queue[0] < left:
                       min_queue.popleft()
           return res
   ```
   
   ```python
   class Solution:
       def shortestSubarray(self, nums: List[int], k: int) -> int:
           preSumArr = [0]
           res = len(nums) + 1
           for num in nums:
               preSumArr.append(preSumArr[-1] + num)
           q = deque()
           for i, curSum in enumerate(preSumArr):
               while q and curSum - preSumArr[q[0]] >= k:
                   res = min(res, i - q.popleft())
               while q and preSumArr[q[-1]] >= curSum:
                   q.pop()
               q.append(i)
           return res if res < len(nums) + 1 else -1
   ```
   
   

## **ğŸ§± å•è°ƒæ ˆç›¸å…³é¢˜ç›®ï¼ˆMonotonic Stackï¼‰**

æœ¬è´¨æ˜¯ä¸€ä¸ªæ ˆï¼Œæ ˆä¸­å…ƒç´ ä¿æŒé€’å¢æˆ–è€…é€’å‡ï¼Œç”¨äºæ‰¾ä¸‹ä¸€ä¸ªæ›´å¤§ï¼ˆå°ï¼‰å…ƒç´ çš„é—®é¢˜ã€‚   

```python
def next_greater_elements(nums):
    res = [-1] * len(nums)
    stack = []  # å­˜ç´¢å¼•ï¼ˆæˆ–å…ƒç´ ï¼‰

    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            res[idx] = nums[i]
        stack.append(i)

    return res
```

### èƒ½çœ‹åˆ°çš„ä¸‹ä¸€ä¸ªäºº

ç¬¬iä¸ªäººèƒ½çœ‹åˆ°çš„æ˜¯ï¼Œåé¢æœ€é«˜äººä¹‹å‰çš„å•å¢åºåˆ—ã€‚ä¸€ä¸ªäººèƒ½ **çœ‹åˆ°** ä»–å³è¾¹å¦ä¸€ä¸ªäººçš„æ¡ä»¶æ˜¯è¿™ä¸¤äººä¹‹é—´çš„æ‰€æœ‰äººéƒ½æ¯”ä»–ä»¬ä¸¤äºº **çŸ®** ã€‚æ›´æ­£å¼çš„ï¼Œç¬¬ `i` ä¸ªäººèƒ½çœ‹åˆ°ç¬¬ `j` ä¸ªäººçš„æ¡ä»¶æ˜¯ `i < j` ä¸” `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`. ä¹Ÿå°±æ˜¯è¯´ï¼Œ[1,2,3]çš„è¯ï¼Œç¬¬ä¸€ä¸ªäººçœ‹ä¸åˆ°ç¬¬ä¸‰ä¸ªäºº

```python
def canSeePersonCount(self, heights: List[int]) -> List[int]:
  					answer = [0] * len(heights)
            left, right = 0, 0
            stack = []
            for right in range(len(heights)):
                # å¸¸è§„å•è°ƒæ ˆçš„æ¨¡æ¿
                while stack and heights[stack[-1]] < heights[right]:
                    idx = stack.pop() # å‡ºç°äº†æ¯” idx æ›´é«˜çš„äºº
                    answer[idx] += 1
                # å¤šäº†ä¸€ä¸ªæ¯”stack[-1] æ›´é«˜çš„äºº
                if stack:
                    answer[stack[-1]] += 1
                stack.append(right)
            return answer
```



1. **84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/largest-rectangle-in-histogram/

   ç»å…¸çš„å•è°ƒæ ˆåº”ç”¨ï¼Œå¯»æ‰¾æ¯ä¸ªæŸ±å­çš„å·¦å³è¾¹ç•Œã€‚

   ```python
   class Solution:
       def largestRectangleArea(self, heights: List[int]) -> int:
           n = len(heights)
           left, right = [0] * n, [0] * n
   
           mono_stack = list()
           for i in range(n):
               while mono_stack and heights[mono_stack[-1]] >= heights[i]:
                   mono_stack.pop()
               left[i] = mono_stack[-1] if mono_stack else -1
               mono_stack.append(i)
           
           mono_stack = list()
           for i in range(n - 1, -1, -1):
               while mono_stack and heights[mono_stack[-1]] >= heights[i]:
                   mono_stack.pop()
               right[i] = mono_stack[-1] if mono_stack else n
               mono_stack.append(i)
           
           ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0
           return ans
   ```

   ```python
   # æ³¨æ„ç»†èŠ‚ä¸‹æ ‡ï¼Œä»¥åŠleftï¼Œrightçš„æ’åˆ—æ–¹å‘
   class Solution:
       def largestRectangleArea(self, heights: List[int]) -> int:
           mono_stack_l, mono_stack_r = [], []
           n = len(heights)
           left_border, right_border = [], []
           for i in range(n):
               # ä¿æŒå•å¢æ ˆï¼Œå¯ä»¥æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºnums[i]çš„æŸ±å­
               while mono_stack_l and heights[mono_stack_l[-1]] >= heights[i]:
                   mono_stack_l.pop()
               if mono_stack_l:
                   left_border.append(mono_stack_l[-1] + 1)
               else:
                   left_border.append(0)
               mono_stack_l.append(i)
           for i in range(n - 1, -1, -1):
               while mono_stack_r and heights[mono_stack_r[-1]] >= heights[i]:
                   mono_stack_r.pop()
               if mono_stack_r:
                   right_border.append(mono_stack_r[-1])
               else:
                   right_border.append(n)
               mono_stack_r.append(i)
           ans = []
           print(left_border)
           print(right_border)
           for i in range(n):
               ans.append((right_border[n-i-1]- left_border[i]) * heights[i])
           return max(ans) if len(ans) > 0 else 0
           
   ```

   

2. **85. æœ€å¤§çŸ©å½¢**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximal-rectangle/

   åŸºäºä¸Šä¸€é¢˜ï¼Œå°†æ¯ä¸€è¡Œçœ‹ä½œç›´æ–¹å›¾ã€‚

3. **496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/next-greater-element-i/

   ä½¿ç”¨å•è°ƒæ ˆå¯»æ‰¾ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ã€‚

4. **503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/next-greater-element-ii/

   å¾ªç¯æ•°ç»„ç‰ˆæœ¬çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ é—®é¢˜ã€‚

5. **901. è‚¡ç¥¨ä»·æ ¼è·¨åº¦**

   é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/online-stock-span/

   ä½¿ç”¨å•è°ƒæ ˆè®¡ç®—è‚¡ç¥¨ä»·æ ¼çš„è·¨åº¦ã€‚