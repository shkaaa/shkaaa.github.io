---
layout:     post
title:      单调队列/单调栈
subtitle:   单调队列/单调栈
date:       2025-04-29
author:     宋鸿堃
header-img: img/post-bg-debug.png
catalog: true
tags:
    - 算法题
    - 单调栈
    - 单调队列
---

# 单调队列/单调栈

## **🧮 单调队列相关题目（Monotonic Queue）**

**单调队列（Monotonic Queue）** 是一种特殊的双端队列（deque），**保持其中的元素单调递增或递减**，并用于在滑动窗口类问题中快速找到**最大值或最小值**。

### **单调递减队列（常用于找最大值）**

每次新元素进来时：

1. **把队尾所有小于新元素的值弹出**（因为它们以后不会再成为最大值）
2. 然后再将当前元素加入队尾
3. 窗口滑出时，如果队首元素已不在窗口范围，就弹出它

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque()
        ans = []
        left, right = 0, 0
        for right in range(len(nums)):
            while q and nums[q[-1]] < nums[right]:
                q.pop()
            q.append(right)
            if right >= k - 1:
                ans.append(nums[q[0]])
                if q[0] <= left:
                    q.popleft()
                left += 1
                
        return ans
```

### **单调递增队列（常用于找最小值）**

1. **239. 滑动窗口最大值**

   题目链接：https://leetcode.cn/problems/sliding-window-maximum/

   使用单调递减队列维护当前窗口内的最大值。

2. **1438. 绝对差不超过限制的最长连续子数组**

   题目链接：https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

   需要同时维护最大值和最小值，可使用两个单调队列。

3. **862. 和至少为 K 的最短子数组**

   题目链接：https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/

   使用前缀和和单调队列优化滑动窗口。

## **🧱 单调栈相关题目（Monotonic Stack）**

```python
def next_greater_elements(nums):
    res = [-1] * len(nums)
    stack = []  # 存索引（或元素）

    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            res[idx] = nums[i]
        stack.append(i)

    return res
```

### 能看到的下一个人

第i个人能看到的是，后面最高人之前的单增序列。一个人能 **看到** 他右边另一个人的条件是这两人之间的所有人都比他们两人 **矮** 。更正式的，第 `i` 个人能看到第 `j` 个人的条件是 `i < j` 且 `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`. 也就是说，[1,2,3]的话，第一个人看不到第三个人

```python
def canSeePersonCount(self, heights: List[int]) -> List[int]:
  					answer = [0] * len(heights)
            left, right = 0, 0
            stack = []
            for right in range(len(heights)):
                # 常规单调栈的模板
                while stack and heights[stack[-1]] < heights[right]:
                    idx = stack.pop() # 出现了比 idx 更高的人
                    answer[idx] += 1
                # 多了一个比stack[-1] 更高的人
                if stack:
                    answer[stack[-1]] += 1
                stack.append(right)
            return answer
```



1. **84. 柱状图中最大的矩形**

   题目链接：https://leetcode.cn/problems/largest-rectangle-in-histogram/

   经典的单调栈应用，寻找每个柱子的左右边界。

2. **85. 最大矩形**

   题目链接：https://leetcode.cn/problems/maximal-rectangle/

   基于上一题，将每一行看作直方图。

3. **496. 下一个更大元素 I**

   题目链接：https://leetcode.cn/problems/next-greater-element-i/

   使用单调栈寻找下一个更大元素。

4. **503. 下一个更大元素 II**

   题目链接：https://leetcode.cn/problems/next-greater-element-ii/

   循环数组版本的下一个更大元素问题。

5. **901. 股票价格跨度**

   题目链接：https://leetcode.cn/problems/online-stock-span/

   使用单调栈计算股票价格的跨度。